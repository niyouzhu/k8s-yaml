image:
  pullPolicy: IfNotPresent
  tag: ""
# -- Passed to all pods created by this chart. Should not ordinarily need to be changed.
imagePullSecrets: []
# -- Override the name of the deploymen. Defaults to {{ .Chart.Name }}.
nameOverride: ""
nodeSelector: {}
podAnnotations: {}
podSecurityContext: {}
securityContext: {}

serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

service:
  # -- Service type for the service that points to the main Budibase proxy pod.
  type: ClusterIP
  # -- Port to expose on the service.
  port: 10000

ingress:
  # -- Whether to create an Ingress resource pointing to the Budibase proxy.
  enabled: true
  # -- What ingress class to use.
  className: ""
  # -- Standard hosts block for the Ingress resource. Defaults to pointing to the Budibase proxy.
  hosts:
    # @ignore
    - host:
      paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: proxy-service
              port:
                number: 10000
  nginx: true
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/client-max-body-size: 150M
    nginx.ingress.kubernetes.io/proxy-body-size: 50m
  aws: false
  certificateArn: ""

# -- Sets the tolerations for all pods created by this chart. Should not ordinarily need to be changed.
# See <https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/> for more information
# on tolerations.
tolerations: []

# -- Sets the affinity for all pods created by this chart. Should not ordinarily
# need to be changed.  See
# <https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/>
# for more information on affinity.
affinity: {}

globals:
  # -- The version of Budibase to deploy. Defaults to what's specified by {{ .Chart.AppVersion }}.
  # Ends up being used as the image version tag for the apps, proxy, and worker images.
  appVersion: ""
  # -- Sets the environment variable BUDIBASE_ENVIRONMENT for the apps and worker pods. Should not
  # ordinarily need to be changed.
  budibaseEnv: PRODUCTION
  # -- Sets what feature flags are enabled and for which tenants. Should not ordinarily need to be
  # changed.
  tenantFeatureFlags: "*:LICENSING,*:USER_GROUPS,*:ONBOARDING_TOUR"
  # -- Whether to enable analytics or not. You can read more about our analytics here:
  # <https://docs.budibase.com/docs/analytics>.
  enableAnalytics: "1"
  # @ignore (only used if enableAnalytics is set to 1)
  posthogToken: phc_bIjZL7oh2GEUd2vqvTBH8WvrX0fWTFQMs6H5KQxiUxU
  # @ignore (should not normally need to be changed, we only set this to "0"
  # when deploying to our Cloud environment)
  selfHosted: "1"
  # @ignore (doesn't work out of the box for self-hosted users, only meant for Budicloud)
  multiTenancy: "0"
  # @ignore (only currently used to determine whether to fetch licenses offline or not, should
  # not normally need to be changed, and only applies to Enterprise customers)
  offlineMode: "0"
  cdnUrl: ""
  # @ignore (only needs to be set in our cloud environment)
  accountPortalUrl: ""
  # @ignore (only needs to be set in our cloud environment)
  accountPortalApiKey: ""
  # -- Sets the domain attribute of the cookie that Budibase uses to store session information.
  # See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_where_cookies_are_sent>
  # for details on why you might want to set this.
  cookieDomain: ""
  # -- Set the `platformUrl` binding. You can also do this in Settings > Organisation if you are
  # self-hosting.
  platformUrl: ""
  # -- Whether or not to enable doing data migrations over the HTTP API. If this is set to "0",
  # migrations are run on startup. You shouldn't ordinarily need to change this.
  httpMigrations: "0"
  # -- Google OAuth settings. These can also be set in the Budibase UI, see
  # <https://docs.budibase.com/docs/sso-with-google> for details.
  google:
    # -- Client ID of your Google OAuth app.
    clientId: ""
    # -- Client secret of your Google OAuth app.
    secret: ""
  # -- The maximum number of iterations allows for an automation loop step. You can read more about
  # looping here: <https://docs.budibase.com/docs/looping>.
  automationMaxIterations: "200"

  # -- Create an internal API key, JWT secret, object store access key and
  # secret, and store them in a Kubernetes `Secret`.
  createSecrets: true

  # -- Used for encrypting API keys and environment variables when stored in the database.
  # You don't need to set this if `createSecrets` is true.
  apiEncryptionKey: ""
  # -- API key used for internal Budibase API calls. You don't need to set this
  # if `createSecrets` is true.
  internalApiKey: "n9Zv0lkJhXewccoNIqVX"
  # -- Secret used for signing JWTs. You don't need to set this if `createSecrets` is true.
  jwtSecret: "uRsoHwzCG17lRorNhnCY"
  # -- A fallback value for `internalApiKey`. If you're rotating your encryption key, you can
  # set this to the old value for the duration of the rotation.
  internalApiKeyFallback: ""
  # -- A fallback value for `jwtSecret`. If you're rotating your JWT secret, you can set this
  # to the old value for the duration of the rotation.
  jwtSecretFallback: ""

  sentryDSN: ""
  smtp:
    # -- Whether to enable SMTP or not.
    enabled: false

services:
  # -- The DNS suffix to use for service discovery. You only need to change this
  # if you've configured your cluster to use a different DNS suffix.
  dns: cluster.local

  proxy:
    # @ignore (you shouldn't need to change this)
    port: 10000
    # -- The number of proxy replicas to run.
    replicaCount: 1
    # @ignore (you should never need to change this)
    upstreams:
      apps: http://app-service.{{ .Release.Namespace }}.svc.{{ .Values.services.dns
        }}:{{ .Values.services.apps.port }}
      couchdb: http://{{ .Release.Name }}-svc-couchdb:{{ .Values.services.couchdb.port
        }}
      minio: http://minio-service.{{ .Release.Namespace }}.svc.{{ .Values.services.dns
        }}:{{ .Values.services.objectStore.port }}
      worker: http://worker-service.{{ .Release.Namespace }}.svc.{{ .Values.services.dns
        }}:{{ .Values.services.worker.port }}
    resources: {}
    # -- Startup probe configuration for proxy pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    startupProbe:
      # @ignore
      httpGet:
        path: /health
        port: 10000
        scheme: HTTP
      # @ignore
      failureThreshold: 30
      # @ignore
      periodSeconds: 3
    # -- Readiness probe configuration for proxy pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    readinessProbe:
      # @ignore
      httpGet:
        path: /health
        port: 10000
        scheme: HTTP
      # @ignore
      periodSeconds: 3
      # @ignore
      failureThreshold: 1
    # -- Liveness probe configuration for proxy pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    livenessProbe:
      # @ignore
      httpGet:
        path: /health
        port: 10000
        scheme: HTTP
      # @ignore
      failureThreshold: 3
      # @ignore
      periodSeconds: 5
  apps:
    # @ignore (you shouldn't need to change this)
    port: 4002
    # -- The number of apps replicas to run.
    replicaCount: 1
    # -- The log level for the apps service.
    logLevel: info
    # -- Whether or not to log HTTP requests to the apps service.
    httpLogging: 1
    # -- The resources to use for apps pods. See
    # <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    # for more information on how to set these.
    resources: {}
    # -- Extra environment variables to set for apps pods. Takes a list of
    # name=value pairs.
    extraEnv: []
    # -- Startup probe configuration for apps pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    startupProbe:
      # @ignore
      httpGet:
        path: /health
        port: 4002
        scheme: HTTP
      # @ignore
      failureThreshold: 30
      # @ignore
      periodSeconds: 3
    # -- Readiness probe configuration for apps pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    readinessProbe:
      # @ignore
      httpGet:
        path: /health
        port: 4002
        scheme: HTTP
      # @ignore
      periodSeconds: 3
    livenessProbe:
      # @ignore
      httpGet:
        path: /health
        port: 4002
        scheme: HTTP
      # @ignore
      failureThreshold: 3
      # @ignore
      periodSeconds: 5


  budibaseVersion: latest

  worker:
    # @ignore (you shouldn't need to change this)
    port: 4003
    # -- The number of worker replicas to run.
    replicaCount: 1
    # -- The log level for the worker service.
    logLevel: info
    # -- Whether or not to log HTTP requests to the worker service.
    httpLogging: 1
    # -- The resources to use for worker pods. See
    # <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    # for more information on how to set these.
    resources: {}
    # -- Startup probe configuration for worker pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    startupProbe:
      # @ignore
      httpGet:
        path: /health
        port: 4003
        scheme: HTTP
      # @ignore
      failureThreshold: 30
      # @ignore
      periodSeconds: 3
    # -- Readiness probe configuration for worker pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    readinessProbe:
      # @ignore
      httpGet:
        path: /health
        port: 4003
        scheme: HTTP
      # @ignore
      periodSeconds: 3
      # @ignore
      failureThreshold: 1
    # -- Liveness probe configuration for worker pods. You shouldn't need to
    # change this, but if you want to you can find more information here:
    # <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>
    # @default -- HTTP health checks.
    livenessProbe:
      # @ignore
      httpGet:
        path: /health
        port: 4003
        scheme: HTTP
      # @ignore
      failureThreshold: 3
      # @ignore
      periodSeconds: 5





  couchdb:
    # -- Whether or not to spin up a CouchDB instance in your cluster. True by
    # default, and the configuration for the CouchDB instance is under the
    # `couchdb` key at the root of this file. You can see what options are
    # available to you by looking at the official CouchDB Helm chart:
    # <https://github.com/apache/couchdb-helm/tree/couchdb-4.3.0/couchdb>.
    enabled: true
    # url: "" # only change if pointing to existing couch server
    # user: "" # only change if pointing to existing couch server
    # password: "" # only change if pointing to existing couch server
    port: 5984
    backup:
      # -- Whether or not to enable periodic CouchDB backups. This works by replicating
      # to another CouchDB instance.
      enabled: false
      # -- Target couchDB instance to back up to, either a hostname or an IP address.
      target: ""
      # -- Backup interval in seconds
      interval: ""
      # -- The resources to use for CouchDB backup pods. See
      # <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
      # for more information on how to set these.
      resources: {}



  redis:
    # -- Whether or not to deploy a Redis pod into your cluster.
    enabled: true
    # -- Port to expose Redis on.
    port: 6379
    # @ignore (you should leave this as 1, we don't support clustering Redis)
    replicaCount: 1
    # -- If you choose to run Redis externally to this chart, you can specify the
    # connection details here.
    url: ""
    # -- The password to use when connecting to Redis. It's recommended that you change
    # this from the default if you're running Redis in-cluster.
    password: "budibase"
    # -- How much persistent storage to allocate to Redis.
    storage: 100Mi
    # -- If defined, storageClassName: <storageClass> If set to "-",
    # storageClassName: "", which disables dynamic provisioning If undefined
    # (the default) or set to null, no storageClassName spec is set, choosing
    # the default provisioner.
    storageClass: ""
    # -- The resources to use for Redis pods. See
    # <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    # for more information on how to set these.
    resources: {}

  objectStore:
    # -- Set to false if using another object store, such as S3. You will need
    # to set `services.objectStore.url` to point to your bucket if you do this.
    minio: true
    # -- Whether to enable the Minio web console or not. If you're exposing
    # Minio to the Internet (via a custom Ingress record, for example), you
    # should set this to false. If you're only exposing Minio to your cluster,
    # you can leave this as true.
    browser: true
    # @ignore
    port: 9000
    # @ignore (you should leave this as 1, we don't support clustering Minio)
    replicaCount: 1
    # -- AWS_ACCESS_KEY if using S3
    accessKey: ""
    # -- AWS_SECRET_ACCESS_KEY if using S3
    secretKey: ""
    # -- AWS_REGION if using S3
    region: ""
    # -- URL to use for object storage. Only change this if you're using an
    # external object store, such as S3. Remember to set `minio: false` if you
    # do this.
    url: "http://minio-service:9000"
    # -- How much storage to give Minio in its PersistentVolumeClaim.
    storage: 100Mi
    # -- If defined, storageClassName: <storageClass> If set to "-",
    # storageClassName: "", which disables dynamic provisioning If undefined
    # (the default) or set to null, no storageClassName spec is set, choosing
    # the default provisioner.
    storageClass: ""
    # -- The resources to use for Minio pods. See
    # <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    # for more information on how to set these.
    resources: {}
    cloudfront:
      # -- Set the url of a distribution to enable cloudfront.
      cdn: ""
      # -- ID of public key stored in cloudfront.
      publicKeyId: ""
      # -- Base64 encoded private key for the above public key.
      privateKey64: ""

# Override values in couchDB subchart. We're only specifying the values we're changing.
# If you want to see all of the available values, see:
#   https://github.com/apache/couchdb-helm/tree/couchdb-4.3.0/couchdb
couchdb:
  # -- The number of replicas to run in the CouchDB cluster. We set this to
  # 1 by default to make things simpler, but you can set it to 3 if you need
  # a high-availability CouchDB cluster.
  clusterSize: 1

  # -- We use a custom CouchDB image for running Budibase and we don't support
  # using any other CouchDB image. You shouldn't change this, and if you do we
  # can't guarantee that Budibase will work.
  image:
    # @ignore
    repository: couchdb
    # @ignore
    tag: 3.1.1
    # @ignore
    pullPolicy: IfNotPresent

  # @ignore
  # This should remain false. We ship Clouseau ourselves as part of the
  # budibase/couchdb image, and it's not possible to disable it because it's a
  # core part of the Budibase experience.
  enableSearch: true
  couchdbConfig:
    couchdb:
      # -- Unique identifier for this CouchDB server instance. You shouldn't need
      # to change this.
      uuid: budibase-couchdb
    chttpd:
      bind_address: any
      require_valid_user: false
  adminUsername: admin
  affinity: {}
  allowAdminParty: false
  annotations: {}



  createAdminSecret: true
  dns:
    clusterDomainSuffix: cluster.local

  erlangFlags:
    name: couchdb
    setcookie: monster
  global: {}

  ingress:
    annotations: []
    enabled: false
    hosts:
    - chart-example.local
    path: /
    tls: null
  initImage:
    pullPolicy: Always
    repository: busybox
    tag: latest
  livenessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  networkPolicy:
    enabled: true
  persistentVolume:
    accessModes:
    - ReadWriteOnce
    enabled: false
    size: 10Gi
    storageClass: ""
  podManagementPolicy: Parallel
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  resources: {}
  searchImage:
    pullPolicy: IfNotPresent
    repository: kocolosk/couchdb-search
    tag: 0.2.0
  service:
    enabled: true
    externalPort: 5984
    type: ClusterIP
  serviceAccount:
    create: true
    enabled: true
  sidecars: {}
  tolerations: []
ingress-nginx:
  controller:
    addHeaders: {}
    admissionWebhooks:
      annotations: {}
      certificate: /usr/local/certificates/cert
      createSecretJob:
        resources: {}
      enabled: true
      existingPsp: ""
      failurePolicy: Fail
      key: /usr/local/certificates/key
      labels: {}
      namespaceSelector: {}
      objectSelector: {}
      patch:
        enabled: true
        image:
          digest: sha256:64d8c73dca984af206adf9d6d7e46aa550362b1d7a01f3a0a91b20cc67868660
          image: ingress-nginx/kube-webhook-certgen
          pullPolicy: IfNotPresent
          registry: k8s.gcr.io
          tag: v1.1.1
        labels: {}
        nodeSelector:
          kubernetes.io/os: linux
        podAnnotations: {}
        priorityClassName: ""
        runAsUser: 2000
        tolerations: []
      patchWebhookJob:
        resources: {}
      port: 8443
      service:
        annotations: {}
        externalIPs: []
        loadBalancerSourceRanges: []
        servicePort: 443
        type: ClusterIP
    affinity: {}
    allowSnippetAnnotations: true
    annotations: {}
    autoscaling:
      behavior: {}
      enabled: false
      maxReplicas: 11
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50
    autoscalingTemplate: []
    config: {}
    configAnnotations: {}
    configMapNamespace: ""
    containerName: controller
    containerPort:
      http: 80
      https: 443
    customTemplate:
      configMapKey: ""
      configMapName: ""
    dnsConfig: {}
    dnsPolicy: ClusterFirst
    electionID: ingress-controller-leader
    enableMimalloc: true
    existingPsp: ""
    extraArgs: {}
    extraContainers: []
    extraEnvs: []
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    healthCheckHost: ""
    healthCheckPath: /healthz
    hostNetwork: false
    hostPort:
      enabled: false
      ports:
        http: 80
        https: 443
    hostname: {}
    image:
      allowPrivilegeEscalation: true
      digest: sha256:f766669fdcf3dc26347ed273a55e754b427eb4411ee075a53f30718b4499076a
      image: ingress-nginx/controller
      pullPolicy: IfNotPresent
      registry: k8s.gcr.io
      runAsUser: 101
      tag: v1.1.0
    ingressClassByName: false
    ingressClassResource:
      controllerValue: k8s.io/ingress-nginx
      default: false
      enabled: true
      name: nginx
      parameters: {}
    keda:
      apiVersion: keda.sh/v1alpha1
      behavior: {}
      cooldownPeriod: 300
      enabled: false
      maxReplicas: 11
      minReplicas: 1
      pollingInterval: 30
      restoreToOriginalReplicaCount: false
      scaledObject:
        annotations: {}
      triggers: []
    kind: Deployment
    labels: {}
    lifecycle:
      preStop:
        exec:
          command:
          - /wait-shutdown
    livenessProbe:
      failureThreshold: 5
      httpGet:
        path: /healthz
        port: 10254
        scheme: HTTP
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    maxmindLicenseKey: ""
    metrics:
      enabled: false
      port: 10254
      prometheusRule:
        additionalLabels: {}
        enabled: false
        rules: []
      service:
        annotations: {}
        externalIPs: []
        loadBalancerSourceRanges: []
        servicePort: 10254
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        metricRelabelings: []
        namespace: ""
        namespaceSelector: {}
        relabelings: []
        scrapeInterval: 30s
        targetLabels: []
    minAvailable: 1
    minReadySeconds: 0
    name: controller
    nodeSelector:
      kubernetes.io/os: linux
    podAnnotations: {}
    podLabels: {}
    podSecurityContext: {}
    priorityClassName: ""
    proxySetHeaders: {}
    publishService:
      enabled: true
      pathOverride: ""
    readinessProbe:
      failureThreshold: 3
      httpGet:
        path: /healthz
        port: 10254
        scheme: HTTP
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    replicaCount: 1
    reportNodeInternalIp: false
    resources:
      requests:
        cpu: 100m
        memory: 90Mi
    scope:
      enabled: false
      namespace: ""
      namespaceSelector: ""
    service:
      annotations: {}
      appProtocol: true
      enableHttp: true
      enableHttps: true
      enabled: true
      external:
        enabled: true
      externalIPs: []
      internal:
        annotations: {}
        enabled: false
        loadBalancerSourceRanges: []
      ipFamilies:
      - IPv4
      ipFamilyPolicy: SingleStack
      labels: {}
      loadBalancerSourceRanges: []
      nodePorts:
        http: ""
        https: ""
        tcp: {}
        udp: {}
      ports:
        http: 80
        https: 443
      targetPorts:
        http: http
        https: https
      type: LoadBalancer
    sysctls: {}
    tcp:
      annotations: {}
      configMapNamespace: ""
    terminationGracePeriodSeconds: 300
    tolerations: []
    topologySpreadConstraints: []
    udp:
      annotations: {}
      configMapNamespace: ""
    updateStrategy: {}
    watchIngressWithoutClass: false
  defaultBackend:
    affinity: {}
    autoscaling:
      annotations: {}
      enabled: false
      maxReplicas: 2
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
      targetMemoryUtilizationPercentage: 50
    containerSecurityContext: {}
    enabled: false
    existingPsp: ""
    extraArgs: {}
    extraEnvs: []
    extraVolumeMounts: []
    extraVolumes: []
    image:
      allowPrivilegeEscalation: false
      image: defaultbackend-amd64
      pullPolicy: IfNotPresent
      readOnlyRootFilesystem: true
      registry: k8s.gcr.io
      runAsNonRoot: true
      runAsUser: 65534
      tag: "1.5"
    labels: {}
    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    minAvailable: 1
    name: defaultbackend
    nodeSelector:
      kubernetes.io/os: linux
    podAnnotations: {}
    podLabels: {}
    podSecurityContext: {}
    port: 8080
    priorityClassName: ""
    readinessProbe:
      failureThreshold: 6
      initialDelaySeconds: 0
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources: {}
    service:
      annotations: {}
      externalIPs: []
      loadBalancerSourceRanges: []
      servicePort: 80
      type: ClusterIP
    serviceAccount:
      automountServiceAccountToken: true
      create: true
      name: ""
    tolerations: []
  global: {}
  imagePullSecrets: []
  podSecurityPolicy:
    enabled: false
  rbac:
    create: true
    scope: false
  revisionHistoryLimit: 10
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ""
  tcp: {}
  udp: {}



autoscaling:
  enabled: false
  maxReplicas: 100
  minReplicas: 1
  targetCPUUtilizationPercentage: 80




